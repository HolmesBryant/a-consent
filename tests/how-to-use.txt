Explanation and How to Use:

Save the Files: Save the three code blocks as test-runner.js, tests.js, and test.html in the same directory.

Place Your Code: Put your original JavaScript code (containing the gtag init, AConsent, and AConsentEdit) into a file named your-script.js (or update the path in test.html). Crucially, ensure AConsent and AConsentEdit are accessible globally or exported as modules as shown in the test.html example. If they are classes inside an IIFE or not exported, the tests won't be able to access them. The module approach (import/export) is generally better.

Open the HTML: Open test.html in your web browser.

Check Console: Open the browser's developer console (usually F12). The test results (suites, passed/failed tests, errors) will be printed there.

#test-container: The tests create and append the custom elements to this div to trigger their lifecycle methods (connectedCallback, etc.) and allow interaction. It's cleared between test groups.

Test Runner: test-runner.js provides describe, it, expect, beforeEach, afterEach, and basic mocking/spying utilities (createSpy, mockWindowProperty, mock localStorage).

Mocks:

localStorage is mocked to prevent tests from interfering with your actual browser storage and to allow predictable states.

window.gtag, console.*, document.*, element.*, Date.now, window.location.reload are spied upon using createSpy to check if they were called and with what arguments.

Spies and mocks are reset in afterEach using TestRunner.restoreAllSpies() and TestRunner.restoreLocalStorage().

Asynchronicity: async/await is used extensively because many operations (connecting elements, dispatching events, handling promises like explodeElement, waiting for transitions) are asynchronous. tick() and shortDelay() are simple helpers to wait for the event loop.

Private Fields/Methods (#): Testing private members like #localDataSet directly is generally discouraged in pure unit testing (you should test through the public API). However, for demonstration and sometimes practical reasons, the example shows accessing them using bracket notation (element['#localDataSet'](...)). This relies on how JavaScript transpiles/handles private fields and might break in the future or with different build tools. Testing via the public methods that use them (submitChoices, init, resetConsent) is the more robust approach.

gtag Initialization Testing: This part is tricky. The test simulates the execution context by evaluating the relevant script block using new Function(). It mocks window, document, and console properties/methods that the script block interacts with before evaluation.

This setup provides a reasonable level of unit testing for your components without relying on external frameworks. Remember that visual aspects (like the actual "fade" or "explode" effects) are hard to unit test and are better suited for integration or end-to-end tests.
